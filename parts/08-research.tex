\chapter{Существующие решения}

В данном разделе рассмотрены основные подсистемы и средства сетевого мониторинга ядра Linux, которые используются в настоящее время.

\section[Обзор средств сетевого мониторинга ядра Linux]{Обзор методов сетевого мониторинга \\ ядра Linux}

\subsection{Утилиты для сетевого мониторинга}
Для современных Linux существует множество утилит для конфигурации и устранения неполадок сетевой подсистемы ядра. 
В основном это инструменты командой строки.  
Наиболее распространенные и часто используемые из них iproute2, ethtool, ping, traceroute, nslookup, netcat, iptables, tcpdump \cite{}, с помощью которых можно узнать конфигурацию сетевых пакетов, проверить наличие соединения и работоспособность DNS, просмотреть таблицу маршрутизации, изучить содержание сетевых пакетов и многое другое, что может помочь определить сбои в сетевой подсистеме.

\textbf{Плюсы:}
\begin{enumerate}
	\item данные утилиты оптимизированы и не могут навредить подсистемам ядра;
	\item имеют документацию о задаче утилиты;
	\item достаточно легки в использовании.
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}
	\item такое множество средств заточено под определенные задачи и их функциональность ограничена программным интерфейсом, предоставленным ядром ОС;
	\item для решение сложных задач необходимо и использовать комбинацию из множества утилит или же не могут справится с такой задачей.
\end{enumerate}

\subsection{Модификация кода ядра Linux}
Открытость ОС Linux позволяет реализовать средства получения информации о событиях, происходящих в сетевой подсистеме ядра, путем модификации исходного кода ядра, что дает возможность находить сбои.

Модификация ядра Linux --- это изменение или модификация кода, которое не несет изменение структур ядра Linux. Модификация с целью сетевого мониторинга \cite{linux_network_implementation} изменение кода сетевой подсистемы ядра Linux, путем добавление функционала вывода информации в системный журнал.

\textbf{Плюсы:}
\begin{enumerate}
	\item ...
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}
	\item модификации ядра имеют доступ ко всему функционалу ядра Linux, включая системные вызовы, коммуникацию с устройствами и т.д. При неверном изменении кода ядра или же сложность модификации повышает вероятность возникновения критических ошибок, способных нарушить работоспособность системы, вследствие чего нельзя достичь необходимого уровня безопасность;
	\item для добавления кода в ядро Linux необходимо строго уметь работать c зыком С и компилятором под данный язык, включая инструменты конфигурации ядра Linux. Необходимо знать интерфейс прикладного программирования ядра (API)\cite{api_kernel}. что усложняет использование данного подхода и требует крайне высоких компетенций разработчика, а иногда команды разработчиков.
	\item также как и при добавлении кода напрямую в ядро, если при работе модуля возникнет ошибка, то есть шанс, что система также экстренно завершит
	работу;
	\item исходя из вышеуказанного процесс модификации довольно длителен.
\end{enumerate}

\subsection{Зондирование ядра Linux}
Второй способ сетевого мониторинга ядра Linux, основывается на встраивании модулей ядра, берет свое начало аналоговой реализации от IBM --- DProbes. DProbes включали в себя, помимо основного зондирующего механизма, обратный интерпретатор, обработчики зондов которого могут быть реализованы как простые функции на языке C, которые будут выполняться в контексте ядра, если они скомпилированы как модуль ядра или даже скомпилированы в ядро.

Использование зондирование ядра (от англ. kernel probe, kprobes) \\ \cite{kernel_probes,kernel_probes_ibm} позволяет входить в работающее ядро для целей отладки, трассировки, оценки производительности, нахождение ошибок и т.п., путем установления точек останова. 
По достижению точки останова, возникает ловушка, регистры сохраняются, а управление передается к соответствующей функции написанного модуля ядра.
После завершения данной функции работа ядра возвращается.  

Большая часть функционала ядра поддерживает зондирование, поэтому с его помощью можно исследовать все ядро. Для того что бы отследить действия сетевой подсистемы необходимо написать модуль ядра для всех функций сетевой подсистемы.
В каждом модуле обозначается имя соответствующей функции и описывается метод, который будет отвечать за мониторинг подсистемы.

\textbf{Плюсы:}
\begin{enumerate}
	\item реализация независимости от конкретной версии ядра упрощает за счет того, что для разных версий нужно адаптировать только название функций.
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}
	\item ответственность за безопасность возрастает благодаря вынесению функциональности в отдельные модули ядра, что повышает вероятность нарушить работу ядра;
	\item за счет динамической загрузки модулей ядра, появляется необходимость постоянной пересборки определенным разработчиком модулей при изменении, что осложняет работу;
	\item ...
\end{enumerate}

\subsection{Точки трассировки}

Точки трассировки (от англ. tracepoints) --- — это статически определенные места в коде ядра Linux, в которых можно запускать пользовательский код \cite{tracepoint_kernel_linux, declarative_tracepoint}.
Точки трассировки, размещенная в коде, обеспечивает перехватчик для вызова функции (пробы), указанные во время выполнения.

Точка трассировки может находится в двух состояниях: <<включена>> (к ней подключен зонд) или <<выключена>> (зонд не подключен).
Когда точка трассировки <<выключена>>, она не имеет никакого эффекта, за исключением времени проверки условия для перехода и пространство для вызова функции и данных.
Когда точка трассировки  <<включена>>, предоставляемая функция вызывается каждый раз при выполнении точки трассировки в контексте выполнения вызывающего объекта. После завершения предоставленной функции, выполнение ядра возвращается в нормальный вид.

Для точек трассировки требуются два элемента:
\begin{itemize}
	\item определение точки трассировки, помещенное в заголовочный файл;
	\item функция вызова, написанная на С.
\end{itemize}

\textbf{Плюсы:}
\begin{enumerate}
	\item важным преимуществом точек трассировки является их принадлежность к стабильному API ядра Linux, вследствие чего, если такая точка объявлена, её нельзя убрать или переместить в следующих версиях ядра;
	\item за счет меньшего использования этих точек понижается использование ресурсов;
	\item также надо отметить по причине стабильности точки трассировки упрощается реализация независимости от конкретной сборки ядра. 
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}
	\item ответственность за безопасность возрастает благодаря вынесению функциональности в отдельные модули ядра, что повышает вероятность нарушить работу ядра;
	\item так как точки трассировки неизменны необходимая информация сетевой подсистемы становится менее подробной.
\end{enumerate}

\subsection{Function Trace}

Function Trace (ftrace) --- это внутренний трассировщик, предназначенный для помощи разработчикам, чтобы узнать, что происходит внутри ядра.
Его можно использовать для отладки или анализа задержек и проблемы с производительностью, происходящие за пределами пользовательского пространства.
Хотя ftrace обычно считается трассировщиком функций, он на самом деле является основой нескольких различных утилит трассировки.
Одним из наиболее распространенных применений ftrace является отслеживание событий.
В ядре есть сотни статических точек событий, которые можно включить через файловую систему tracefs, чтобы увидеть, что происходит в определенных частях ядра.

Ftrace использует файловую систему tracefs для хранения управляющих файлов как файлы для отображения вывода.

\subsection{Berkeley Packet Filter}
В 1992 году Стивен Маккейн и Ван Якобсон опубликовали статью The BSD Packet Filter: A New Architecture for User-Level Packet Capture («Пакетный фильтр BSD: новая архитектура для захвата пакетов на уровне пользователя»).
В ней они описали способ реализации фильтра сетевых пакетов для ядра Unix, который работал в 20 раз быстрее, чем все остальные, имеющиеся
на то время в области фильтрации пакетов.
Пакетные фильтры имеют конкретную цель: предоставлять приложениям, которые отслеживают сетевую активность, прямую информацию из ядра. Обладая этой информацией, приложения могут решить, что делать с пакетами.
BPF представил два серьезных нововведения в области фильтрации пакетов

Berkeley Packet Filter (BPF) — это подсистема ядра, которая может проверять новые источники информации.
BPF позволяет писать программы, которые выполняются безопасно, когда ядро реагирует на какое-либо событие.
BPF обеспечивает безопасность, чтобы предотвратить системные сбои и вредоносное поведение каких-либо программ.
BPF предоставляет новое поколение инструментов, которые помогают разработчикам систем
наблюдать за новыми платформами и работать с ними.


\subsection{Extended Berkeley Packet Filter}

\textbf{TODO: вообще надо ил оно? может просто соединить в раздел с BPF}

\clearpage

\section{Критерии сравнения методов сетевого мониторинга}

В данном разделе будут описаны критерии, которые будут использоваться для сравнения подсистем и средств сетевого мониторинга ядра.

\begin{table}[h!]
	\begin{center}
		\begin{threeparttable}
			\caption{\label{tb:criteria}Критерии сравнения подсистем и средств сетевого мониторинга ядра}
			\begin{tabular}{|c|p{8cm}|}
				\hline
				\textbf{Критерий} & \textbf{Описание} \\ \hline
				\textbf{Производительность} & Работа при реальной нагрузки и низкие накладные расходы. \\ \hline
				\textbf{Безопасность} & Наличие гарантии, что внесенный код не вызовет остановку системы. \\ \hline
				\textbf{Гибкость} & Возможность подстроиться под любые поставленные задачи. \\ \hline
				\textbf{Независимость} & Независимость от версии ядра. \\ \hline
				\textbf{Простота использования} & Насколько сложно использовать данное средство мониторинга. \\ \hline
				\textbf{Простота развертывания} & Насколько сложно развертывать средства мониторинга на большом количестве машин. \\ \hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

\clearpage

\section{Сравнение методов сетевого мониторинга}

\begin{table}[h!]
	\begin{center}
		\begin{threeparttable}
			\caption{\label{tab:comparison_1} Сравнение методов сетевого мониторинга (Часть 1)}
			\begin{tabular}{|p{0.3\linewidth}|p{0.2\linewidth}|p{0.2\linewidth}|p{0.2\linewidth}|}
				\hline
				\textbf{Критерий} & \textbf{Утилиты} & \textbf{ftrace} & \textbf{BPF/eBFC} \\ \hline
				\textit{Производительность} & \cmark & \cmark & \cmark \\ \hline
				\textit{Безопасность} & \cmark & \cmark & \cmark \\ \hline
				\textit{Гибкость} & \xmark & \xmark & \xmark \\ \hline
				\textit{Независимость} & \xmark & \cmark & \cmark \\ \hline
				\textit{Простота использования} & \cmark & \xmark & \cmark \\ \hline
				\textit{Простота развертывания} & \cmark & \xmark & \cmark \\ \hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}


\begin{table}[h!]
	\begin{center}
		\begin{threeparttable}
			\captionsetup{justification=raggedright,singlelinecheck=off}
			\caption{\label{tab:comparison_2} Сравнение методов сетевого мониторинга (Часть 2)}
			\begin{tabular}{|p{0.3\linewidth}|p{0.2\linewidth}|p{0.2\linewidth}|p{0.2\linewidth}|}
				\hline
				\textbf{Критерий} & \textbf{Модификация кода ядра} & \textbf{Зондирование ядра} & \textbf{Точки трассировки} \\ \hline
				\textit{Производительность} & \xmark & \cmark/\xmark\footnotemark{} & \cmark \\ \hline
				\textit{Безопасность} & \xmark & \cmark/\xmark & \cmark/\xmark \\ \hline
				\textit{Гибкость} & \cmark/\xmark & \cmark & \cmark  \\ \hline
				\textit{Независимость}  & \xmark & \cmark/\xmark & \cmark  \\ \hline
				\textit{Простота использования}  & \xmark & \xmark & \xmark \\ \hline
				\textit{Простота развертывания}  & \xmark & \cmark/\xmark & \cmark/\xmark \\ \hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

\footnotetext{Средство или подсистема сетевого мониторинга ядра Linux в реализации данного требования возможно, но осложнена.}
