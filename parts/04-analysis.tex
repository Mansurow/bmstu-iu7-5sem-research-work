\chapter{Анализ предметной области}

Прежде чем приступить к обзору и анализу существующих средств сетевого мониторинга ядра Linux, необходимо определить что подразумевается под сетевым мониторингом ядра Linux

\section{Ядро Linux}
Ядро Linux --- это основной внутренний компонент операционной системы Linux, отвечающие за распределением системными ресурсами, управление аппаратным обеспечением и обеспечение взаимодействие приложения с аппаратным обеспечением~\cite{kernel_linux_robert}.

В Linux системах ядро является монолитным с модульной конструкцией, которое реализовано в виде одного большого процесса, выполняющий в одном адресном пространстве.
Такие ядра обычно хранятся на диске в виде одного большого статического бинарного файла.
Все службы ядра находятся и выполняются в одном большом адресном пространстве ядра.
Взаимодействия в ядре осуществляются очень просто, потому что все, что выполняется в режиме ядра, выполняется в одном адресном пространстве.
В отличие от микроядра, который разделяет службы ядра на несколько процессов, называемыми серверами.
Ядро может вызывать функции непосредственно, как это делают пользовательские приложения.

Главным задачами ядра в первую очередь является:
\begin{enumerate}
	\item обеспечение среды выполнения для программ в операционной системе;
	\item взаимодействие с аппаратными компонентами и обслуживание их низкоуровневые элементы.
\end{enumerate}

В современных системах с устройствами управления защищенной памятью ядро обычно занимает привилегированное положение по отношению к пользовательским программам. Это включает доступ ко всем областям защищенной памяти и полный доступ к аппаратному обеспечению. Системные переменные (system state) и область памяти, в которой находится ядро, вместе называются пространством ядра (kernel-space), или привилегированным режимом, или также называется <<режим ядра>>. Соответственно, пользовательские программы выполняются в пространствах задач (user-space), или в <<пользовательском режиме>>.

\section{Подсистемы ядра}
Ядро Linux разделяется на ряд подсистем, рисунок \ref{img:arch_linux}, как на высоком, так и на низких уровнях. Такое разделение позволяет упростить разработку ядра и сделать его более гибким.
Каждая подсистема выполняет реализует свой функционал, такие как управление памятью, управление и взаимодействие процессов, файловая система, сетевые стек, которое используется другими подсистемами.  

\begin{figure}[h!]
	\centering
	\includegraphics[height=0.4\textheight]{img/arch_linux} % height
	\caption{Общая архитектура Linux}
	\label{img:arch_linux}
\end{figure}

\clearpage

\section{Сетевая подсистема ядра}

Сетевая подсистема ядра Linux \cite{moduls_kernel_linux, linux_network_internals} обеспечивает взаимодействие процессов, выполняющихся на разных узлах сети, то есть дает возможность сетевого взаимодействия между приложениями .

Сетевая подсистема ядра Linux реализует следующий функционал:
\begin{itemize}
	\item поддержку взаимодействия процессов с помощью механизмов сокетов (sockets);
	\item реализацию стеков сетевых протоколов (TCP/IP, UDP/IP, IPX/SPX и другие);
	\item поддержку сетевых интерфейсов;
	\item обеспечение маршрутизации пакетов (routing);
	\item обеспечение фильтрации пакетов (netfilter).
\end{itemize}

Взаимодействие сетевой подсистемы с другими подсистема ядра показана на рисунке \ref{img:arch_linux}.

\subsection{Многоуровневая модель}

Для решения задачи сетевых взаимодействий применяется многоуровневый иерархический подход, заключающийся в разбиении процесса коммуникации на набор уровней с четко определенными способами взаимодействия уровней на одном узле и на соседних узлах. 
Таким образом в подсистеме существует сетевой стек, который является производной стека BSD.
Сетевой стек хорошо оснащен добротным набором интерфейсов, которые варьируются от протоколо-независимых (protocol agnostic), таких как интерфейс уровня общих сокетов или уровня устройств, до специальных интерфейсов конкретных сетевых протоколов. 
Уровень сокетов представляет собой стандартный API к сетевой подсистеме. 
Он предоставляет пользовательский интерфейс к различным сетевым протоколам. 
Уровень сокетов реализует стандартизованный способ управления соединениями и передачи данных между конечными точками, от доступа к <<чистым>> кадрам данных и блокам данных протокола IP/PDU, и до протоколов TCP/UDP.

В то время как работа в сети отсылается к модели сетевого взаимодействия по OSI, сетевой стек в Linux использует модель TCP/IP \cite{tcpip_craig, tcpip_lora}, включающая в себя 4 уровня:
\begin{enumerate}
	\item уровень сетевых интерфейсов (канальный уровень) относится к драйверам устройств, обеспечивающим доступ к физическому уровню, который может состоять из многочисленных сред, таких как последовательные каналы или устройства Ethernet, описываются как сетевые интерфейсы;
	\item уровень межсетевого взаимодействия (сетевой уровень) обеспечивает работу базовой
	службы доставки пакетов по назначению;
	\item транспортный уровень обеспечивает надежную доставку данных со сквозным обнаружением и устранением ошибок;
	\item прикладной уровень отвечает за взаимодействие с приложениями и процессами на хостах, также определяются пользовательские интерфейсы процесса или приложения, наблюдается работа протоколов и служб --- FTP, Telnet и другие. 
\end{enumerate}
Сетевая модель TCP/IP условно согласуется с моделью OSI, включающая в себя 7 уровней:
\begin{enumerate}
	\item физический уровень;
	\item канальный уровень;
	\item сетевой уровень;
	\item транспортный;
	\item сеансовый уровень;
	\item представительский уровень;
	\item прикладной уровень.
\end{enumerate}

\clearpage

На рисунке \ref{img:protocol} показано как модели  TCP/IP и OSI пересекаются между собой.
\begin{figure}[h!]
	\centering
	\includegraphics[height=0.3\textheight]{img/protocol}
	\caption{Модель OSI и TCP/IP}
	\label{img:protocol}
\end{figure}

\subsection{Сетевой интерфейс}

Сетевые интерфейсы являются основой сетевой подсистемы, иначе говоря абстракцией, используемые для представления связи устройств сети с протоколом TCP/IP и передачи данных через некоторые линии связи.
Основными устройствами, позволяющими организовывать взаимодействие по сети, являются сетевые адаптеры (Ethernet-карты).

Интерфейс имеет набор параметров, большинство которых относятся к сетевому уровню (IP-адрес, маска сети и т.п.).
Важным параметром сетевого интерфейса является аппаратный адрес. 
В Ethernet аппаратный адрес называется MAC-адрес и состоит из шести байтов, которые принято записывать в шестнадцатеричной системе исчисления и разделять двоеточиями.

\textbf{TODO: возможно включить подробности}

\section{Сетевой мониторинг ядра}

Сетевой мониторинг ядра Linux --- это контролирование пакетов и нахождение наличие ошибок сетевых интерфейсов сетевой подсистемы, что относится вмешательством в работу подсистемы и ее сетевого стека.

\textbf{TODO: подробнее описать ПОПРАВИТЬ}
Часто мониторинг сетевой подсистемы операционной системы заканчивается на счетчиках пакетов, октетов и ошибок сетевых интерфейсах. Но это только 2й уровень модели OSI!
С одной стороны большинство проблем с сетью возникают как раз на физическом и канальном уровнях, но с другой стороны приложения, работающие с сетью оперируют на уровне TCP сессий и не видят, что происходит на более низких уровнях.

\chapter{Существующие решения}

В данном разделе рассмотрены основные подсистемы и средства сетевого мониторинга ядра Linux, которые используются в настоящее время.

\section[Обзор средств сетевого мониторинга ядра Linux]{Обзор методов сетевого мониторинга \\ ядра Linux}

\subsection{Утилиты для сетевого мониторинга}
Для современных Linux существует множество утилит для конфигурации и устранения неполадок сетевой подсистемы ядра. 
В основном это инструменты командой строки.  
Наиболее распространенные и часто используемые из них iproute2, ethtool, ping, traceroute, nslookup, netcat, iptables, tcpdump \cite{}, с помощью которых можно узнать конфигурацию сетевых пакетов, проверить наличие соединения и работоспособность DNS, просмотреть таблицу маршрутизации, изучить содержание сетевых пакетов и многое другое, что может помочь определить сбои в сетевой подсистеме.

\textbf{Плюсы:}
\begin{enumerate}
	\item данные утилиты оптимизированы и не могут навредить подсистемам ядра;
	\item имеют документацию о задаче утилиты;
	\item достаточно легки в использовании.
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}
	\item такое множество средств заточено под определенные задачи и их функциональность ограничена программным интерфейсом, предоставленным ядром ОС;
	\item для решение сложных задач необходимо и использовать комбинацию из множества утилит или же не могут справится с такой задачей.
\end{enumerate}

\subsection{Модификация кода ядра Linux}
Открытость ОС Linux позволяет реализовать средства получения информации о событиях, происходящих в сетевой подсистеме ядра, путем модификации исходного кода ядра, что дает возможность находить сбои.

Модификация ядра Linux --- это изменение или модификация кода, которое не несет изменение структур ядра Linux. Модификация с целью сетевого мониторинга \cite{linux_network_implementation} изменение кода сетевой подсистемы ядра Linux, путем добавление функционала вывода информации в системный журнал.

\textbf{Плюсы:}
\begin{enumerate}
	\item данный подход позволяет решить любую задачу;
	\item ...
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}
	\item модификации ядра имеют доступ ко всему функционалу ядра Linux, включая системные вызовы, коммуникацию с устройствами и т.д. При неверном изменении кода ядра или же сложность модификации повышает вероятность возникновения критических ошибок, способных нарушить работоспособность системы, вследствие чего нельзя достичь необходимого уровня безопасность;
	\item для добавления кода в ядро Linux необходимо строго уметь работать c зыком С и компилятором под данный язык, включая инструменты конфигурации ядра Linux. Необходимо знать интерфейс прикладного программирования ядра (API)\cite{api_kernel}. что усложняет использование данного подхода и требует крайне высоких компетенций разработчика, а иногда команды разработчиков.
	\item также как и при добавлении кода напрямую в ядро, если при работе модуля возникнет ошибка, то есть шанс, что система также экстренно завершит
	работу;
	\item исходя из вышеуказанного процесс модификации довольно длителен.
\end{enumerate}

\subsection{Зондирование ядра Linux}
Второй способ сетевого мониторинга ядра Linux, основывается на встраивании модулей ядра, берет свое начало аналоговой реализации от IBM --- DProbes. DProbes включали в себя, помимо основного зондирующего механизма, обратный интерпретатор, обработчики зондов которого могут быть реализованы как простые функции на языке C, которые будут выполняться в контексте ядра, если они скомпилированы как модуль ядра или даже скомпилированы в ядро.

Использование зондирование ядра (от англ. kernel probe, kprobes) \\ \cite{kernel_probes,kernel_probes_ibm} позволяет входить в работающее ядро для целей отладки, трассировки, оценки производительности, нахождение ошибок и т.п., путем установления точек останова. 
По достижению точки останова, возникает ловушка, регистры сохраняются, а управление передается к соответствующей функции написанного модуля ядра.
После завершения данной функции работа ядра возвращается.  

Большая часть функционала ядра поддерживает зондирование, поэтому с его помощью можно исследовать все ядро. Для того что бы отследить действия сетевой подсистемы необходимо написать модуль ядра для всех функций сетевой подсистемы.
В каждом модуле обозначается имя соответствующей функции и описывается метод, который будет отвечать за мониторинг подсистемы.
  
\textbf{Плюсы:}
\begin{enumerate}
	\item данный подход позволяет решить любую задачу;
	\item реализация независимости от конкретной версии ядра упрощает за счет того, что для разных версий нужно адаптировать только название функций.
\end{enumerate}

\textbf{Недостатки:}
\begin{enumerate}
	\item ответственность за безопасность возрастает благодаря вынесению функциональности в отдельные модули ядра, что повышает вероятность нарушить работу ядра;
	\item за счет динамической загрузки модулей ядра, появляется необходимость постоянной пересборки определенным разработчиком модулей при изменении, что осложняет работу;
	\item для добавления модуля в ядро Linux необходимо строго уметь работать c зыком С и компилятором под данный язык, включая инструменты конфигурации ядра Linux. Необходимо знать интерфейс прикладного программирования ядра (API)\cite{api_kernel}. что усложняет использование данного подхода и требует крайне высоких компетенций разработчика, а иногда команды разработчиков;
	\item ...
\end{enumerate}

\subsection{Точки трассировки}

\subsection{ftrace}

\subsection{Berkeley Packet Filter}

\subsection{Extended Berkeley Packet Filter}

\clearpage

\section{Критерии сравнения методов сетевого мониторинга}

В данном разделе будут описаны критерии, которые будут использоваться для сравнения подсистем и средств сетевого мониторинга ядра.

\begin{table}[h!]
	\begin{center}
		\begin{threeparttable}
			\caption{\label{tb:criteria}Критерии сравнения подсистем и средств сетевого мониторинга ядра}
			\begin{tabular}{|c|p{8cm}|}
				\hline
				\textbf{Критерий} & \textbf{Описание} \\ \hline
				\textbf{Производительность} & Быстрота работы программ. \\ \hline
				\textbf{Безопасность} & Наличие гарантии, что внесенный код не вызовет остановку системы. \\ \hline
				\textbf{Скорость разработки} & Скорость разработки , если оно требуется. \\ \hline
				\textbf{Гибкость} & Возможность подстроиться под любые поставленные задачи. \\ \hline
				\textbf{Простота отладки} & Является ли написанные модификации простыми в отладке, если отладка имеется. \\ \hline
				\textbf{Поддержка} & Поддержка разработчиками ядра при его написании, зависимость от версий. \\ \hline
				\textbf{Простота развертывания} & Насколько сложно развертывать средства мониторинга на большом количестве машин. \\ \hline
				\textbf{Простота использования} & Насколько сложно использовать данное средство мониторинга. \\ \hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}

\clearpage

\section{Сравнение методов сетевого мониторинга}
